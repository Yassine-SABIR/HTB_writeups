# HTB Embryonic Plant yabir

from Crypto.Util.number import getPrime, long_to_bytes, inverse
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from hashlib import sha256

n = 875160154252520186251141359813376844205078837688859219647998263059390545455666959868272831956779132045330105458640460325486680058028233270020291614157451317894110269639780507518860757299450578151147748572019371950843986400076289065334864577087504297359676338166424192877389197803442490978821375794048316553853085966558794240760959161987598108459441945291723309230665829568115073301763544532552179053221908864303864014278134933463597319119189753348991487712539547783209384907074459767339389912999640300731884080101606842315180302622347685382825488775275363493924203654141256657466019975768214244502429057343992946031175889606627829209702720334661107181627261133702840164098042293465302874342367
s = [45948196110742333078791904670754464213578139076280109814760521831353273605782767324779081189039031009815013571451298379981707915542440414220083426012609548317078548002379773850309022768943249397294154504631709396600886029113258544, 665421018479354408650321321446504004021595291664664613059639369284378526681870680990726015080235767661978417143890017835302285399955943814186163819783105747360598346167878408804511855184450139017542601099343516459031570045750334635, 116901116055486713179543809270968616175254891027356317875260251653063459332706332539151662885597749087527500088196623717000607610204151297409257838680010556067036481294394312559141590536968964270065614095041734217016802912127551399, 257185387102952423422505329148493981831897715690584197952849048768011651303898015179171902245107615610642197589412557491017458513344338002354160349045327465820185865360211004133692933165886876481285477189851986291296987966454584913, 600597039831835988459465667623398229366883082253281715825043750022005882279772326647162809398726368298023180858058246314753665389921411839577046046481816334727242911521098595075675355340100111145925656700034968689114367721111389240]
enc_flag = bytes.fromhex("df534b412fbbb5bf920a9c8a76f85013b2c6cb49642c30a7e5e801f9576b4f36071945f46d3e78c8b1e2adff0c090d7d88e9a068caae958d87ca56bcd0763e00e527371f271530bd6bb779284233ec45")

e = 0x10001

"""
We have:
    s[1] = p * s[0] + q % r
    s[2] = p * s[1] + q % r
    s[3] = p * s[2] + q % r
So:
    s[2] - s[1] = p * (s[1] - s[0]) % r     
    s[3] - s[2] = p * (s[2] - s[1]) % r

    (s[2] - s[1]) ** 2 = p * (s[1] - s[0]) * (s[2] - s[1]) % r  = (s[1] - s[0]) * (s[3] - s[2]) % r

So, r divides a = (s[2] - s[1]) ** 2 - (s[1] - s[0]) * (s[3] - s[2]) and n
    r = gcd(a, n)

"""
def gcd(a, b):
    if a < b:
        return gcd(b,a)

    if b == 0:
        return a
    
    return gcd(b, a%b)


a = (s[2] - s[1]) ** 2 - (s[1] - s[0]) * (s[3] - s[2])

r = gcd(a, n)

"""
Now that we have determined the value of r, we only need to get the values of p and q

To do so, we have:

    s[2] - s[1] = p * (s[1]-s[0]) % r

    so p = (s[2] - s[1])*inverse(s[1]-s[0]) % r, (because p < r)

"""

p = ((s[2] - s[1]) * pow(s[1] - s[0], -1, r)) % r

"""
For q, we have :
    q = s[1] - p * s[0] % r, (because q < r)
"""

q = (s[1] - p * s[0]) % r

#Verification:
print(r*p*q == n) # True

phi = (p - 1) * (q - 1) * (r - 1)

d = inverse(e, phi)

key = sha256(long_to_bytes(d)).digest()
cipher = AES.new(key, AES.MODE_ECB)
Flag_hex = unpad(cipher.decrypt(enc_flag), 16)

print(Flag_hex) # HTB{0op5_my_$33d$_f311_0ff_5h3_gr0und_4nd_br0ugh5_y0u_4_fl4g!#@$%}
